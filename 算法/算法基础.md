# 算法基础

## 一、数学基础

## 二、数据结构

### 2.1 线性表

数组，链表，栈，队列，块状链表

### 2.2 集合

**散列表**

解决散列冲突：
+ 开散列法（链接法）
+ 开放寻址法（闭散列法）

**并查集问题（union-find）**

问题描述：不相交集为一组彼此不相交的集合，并查集算法作用于一个不相交集，可以用近乎常数的时间完成两种操作：
+ 查找：确定元素所在的集合，一般用来判断两个元素是否在同一个集合
+ 合并：将两个集合合并成一个集合

对于每个集合使用一个代表元表示该集合，将所有的元素组织成以代表元为根的树形结构。
查找时可以将x到根节点路径上的所有点的parent都设置为根节点（压缩路径）。
合并时，将小的那个集合的parent设置为元素多的那个集合的代表元

### 2.3 排序

**朴素的排序算法**
|排序方法|平均情况|最好情况|最坏情况|辅助空间|稳定性|
|---|---|---|---|---|---|
|冒泡排序|$O(n^2)$|$O(n)$|$O(n^2)$|$O(1)$|稳定|
|选择排序|$O(n^2)$|$O(n^2)$|$O(n^2)$|$O(1)$|不稳定|
|插入排序|$O(n^2)$|$O(n)$|$O(n^2)$|$O(1)$|稳定|
|归并排序|$O(nlogn)$|$O(nlogn)$|$O(nlogn)$|$O(1)$|稳定|
|希尔排序|$O(n^2) - O(log n)$|$O(n^1.3)$|$O(n^2)$|$O(1)$|不稳定|
|堆排序|$O(nlogn)$|$O(nlogn)$|$O(nlogn)$|$O(1)$|不稳定|
|快速排序|$O(nlogn)$|$O(nlogn)$|$O(n^2)$|$O(n)$|不稳定|

最快的排序方法应该是桶排序，但是桶排序有两点缺点：
    1. 待排元素不能是负数和小数
    2. 空间复杂度不确定，要看待排元素中的最大值

**线性排序算法**

+ 计数排序：假定输入的n个元素介于0到k之间的整数
+ 基数排序：从最低位开始排序，依次拍到最高位
+ 分桶排序，完成后合并

### 2.4 树

+ 二叉堆：最大堆和最小堆
+ 左偏树：
+ 二叉树
+ 线段树

## 三、图论

### 3.1 图

### 3.2 树

### 3.3 二分图

### 3.4 网络流

## 四、计算几何

### 4.1 向量

### 4.2 点的有序化

### 4.3 多边形与圆

### 4.4 半平面交

### 4.5 经典问题

## 五、部分经典问题

## 六、求解策略

## 七、刷题网站

+ [USACO，全美信息学奥林匹克竞赛](http://train.usaco.org/usacogate)
+ [CII,Baylor大学在线测评系统](https://www.construction-institute.org/)
+ [PKU,国内的测评系统](http://poj.org)
+ [SGU,可能比较难](http://acm.sgu.ru)
+ [SPOJ](http://www.spoj.pl/)


## 动态规划

1. 基本的动态规划

和贪心算法一样，动态规划可以将一个问题的解决方案视为一系列决策的结果。不同的是每次贪心算法准则会做出一个不可撤回的决策，而动态规划中，还要考虑每个最优决策序列中是否包含一个最优子序列。

解决动态规划首先要确定子问题，判断哪些变量和问题规模的大小有关；其次是确定状态，推出**状态方程**。

